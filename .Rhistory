tmpfile(fileext='.laz')
tempfile(fileext='.laz')
x = tempfile(fileext='.laz')
x
basename(x)
tools::file_ext(x)
#' compress_las('E:/my/las/dir/')
#' @export
# Check for LAX index files and create them as necessary. An earlier version
# of this function overwrote the original LAS resulting in possible corruption
# of the original file if the process was interrupted. This updated version uses
# temporary files to avoid this problem.
# Check for LAX index files and create them as necessary. An earlier version
# of this function overwrote the original LAS resulting in possible corruption
# of the original file if the process was interrupted. This updated version uses
# temporary files to avoid this problem.
check_for_lax = function(dir, rewrite=TRUE) {
#check inputs for validity
if(!rewrite %in% c(TRUE, FALSE)) stop('rewrite must be TRUE/FALSE')
laz = list.files(dir, pattern='.las|laz', full.names = TRUE)
if(length(laz) < 0) stop('no .LAS or .LAZ found in `dir`')
#check which files are missing indexes
lax = list.files(dir, pattern='.lax', full.names = TRUE)
needs_lax = !gsub('.las|.laz', '', laz) %in% gsub('.lax', '', lax)
cat(sum(needs_lax), 'files need indexing\n')
#return list of needed indexes if rewrite == false
if(!rewrite) return(laz[needs_lax])
# if rewrite == TRUE, add index
for(i in laz[needs_lax]) {
ext = tools::file_ext(i)
fn = tempfile(fileext=paste0('.',i))
cat('file', i, '\n...reading\n')
x = lidR::readLAS(i)
cat('...indexing\n')
lidR::writeLAS(x, fn, index=TRUE)
fn_index = gsub(ext, 'lax', fn)
orig_index = gsub('.laz|.las', '.lax', i)
if(file.exists(fn)) {
cat('...saving\n')
#copy temp files and cleanup
file.copy(fn_index, orig_index)
unlink(fn_index)
unlink(fn)
}  else {
warning('indexing file ', i, ' was unsuccessful')
}
}
}
#' @param dir path to a directory containing .LAS or .LAZ files to index
#' @param write_lax indicates if .lax file should be written (`TRUE`), or only
#' checked for (`FALSE`)
#' @examples
#' check_for_lax('E:/my/las/dir/')
#' @export
# Check for LAX index files and create them as necessary. An earlier version
# of this function overwrote the original LAS resulting in possible corruption
# of the original file if the process was interrupted. This updated version uses
# temporary files to avoid this problem.
check_for_lax = function(dir, write_lax=TRUE) {
#check inputs for validity
if(!write_lax %in% c(TRUE, FALSE)) stop('write_lax must be TRUE/FALSE')
laz = list.files(dir, pattern='.las|laz', full.names = TRUE)
if(length(laz) < 0) stop('no .LAS or .LAZ found in `dir`')
#check which files are missing indexes
lax = list.files(dir, pattern='.lax', full.names = TRUE)
needs_lax = !gsub('.las|.laz', '', laz) %in% gsub('.lax', '', lax)
cat(sum(needs_lax), 'files need indexing\n')
#return list of needed indexes if write_lax == false
if(!write_lax) return(laz[needs_lax])
# if write_lax == TRUE, add index
for(i in laz[needs_lax]) {
ext = tools::file_ext(i)
fn = tempfile(fileext=paste0('.',ext))
cat('file', i, '\n...reading\n')
x = lidR::readLAS(i)
cat('...indexing\n')
lidR::writeLAS(x, fn, index=TRUE)
fn_index = gsub(ext, 'lax', fn)
orig_index = gsub('.laz|.las', '.lax', i)
if(file.exists(fn)) {
cat('...saving\n')
#copy temp files and cleanup
file.copy(fn_index, orig_index)
unlink(fn_index)
unlink(fn)
}  else {
warning('indexing file ', i, ' was unsuccessful')
}
}
}
getwd()
setwd('GitHub/landecoutils/')
devtools::document()
rm(list=ls())
devtools::document()
library(landecoutils)
library(lidR)
library(sf)
library(ggplot2)
library(lidRviewer)
laz_dir = 'X:/testing_density/'
output_dir = laz_dir
dir.create(paste0(output_dir, '/tiled'))
default_proj = 'epsg:32616'
ctg = readLAScatalog(laz_dir);
plot(ctg)
# Code to loop through and replace all .laz with distance files
las_fns = list.files(laz_dir, pattern = '.las|.laz', full.names=TRUE)
for(las_fn in las_fns) {
# Add distance to laz file
las = las_add_scanner_distance(las_fn)
if(is.null(las)) {
warning('skipping\n')
next
}
ext = tools::file_ext(las_fn)
tmp_filename = gsub(paste0('.', ext, '$'), paste0('_tmp.', ext), las_fn)
message('... writing file')
lidR::writeLAS(las, tmp_filename)
if(file.exists(tmp_filename)) {
file.copy(tmp_filename,las_fn, overwrite = TRUE)
if(file.exists(las_fn)) unlink(tmp_filename)
}
# Load or generate scan locations
scan_locations = paste0(output_dir, '/scan_locs.shp')
if(!file.exists(scan_locations)) {
proj = get_ctg_crs(ctg)
tmp = landecoutils::find_ctg_centroids(ctg, 4)
sf::st_crs(tmp) = proj
tmp = sf::st_transform(tmp, default_proj)
# be sure to write output locations##
write_sf(tmp, scan_locations) # be sure to give output loc.
}; scan_locations = read_sf(scan_locations)
# Load or generate site boundary
bnd = paste0(output_dir, '/boundary.shp')
if(!file.exists(bnd)) {
tmp = scan_locations
tmp = st_convex_hull(st_union(tmp))
sf::st_crs(tmp) = st_crs(scan_locations)
write_sf(tmp, bnd)
}; bnd = read_sf(bnd)
#Stitch and merge scans into tiles
ctg = readLAScatalog(laz_dir); plot(ctg)
opt_chunk_alignment(ctg) = c(0,0)
stitch_TLS_dir_to_LAS_tiles(ctg = ctg,
out_dir = paste0(output_dir,'/tiled/'),
bnd = st_transform(bnd, get_ctg_crs(ctg)),
tile_size = 30,
n_cores = 1,
buffer = 5, #defaults to 10
max_scan_distance = 40, # defaults to 60
scan_locations = st_transform(scan_locations, get_ctg_crs(ctg)))
laz_dir
output_dir
laz_dir = paste0(output_dir, '/tiled/')
list.files(laz_dir)
list.files(laz_dir, pattern = '.laz$')
las_fns = list.files(laz_dir, pattern = '.laz$', full.names = TRUE)
las_fn = las_fns[1]
las = readLAS(las_fn)
colnames(las@data)
colnames(las@data$UserData)
head(las@data$UserData)
mean(las@data$UserData)
table(las@data$UserData)
#Stitch and merge scans into tiles
ctg = readLAScatalog(laz_dir); plot(ctg)
opt_chunk_alignment(ctg) = c(0,0)
out_dir = paste0(output_dir,'/tiled/')
bnd = st_transform(bnd, get_ctg_crs(ctg))
tile_size = 30
n_cores = 1
buffer = 5 #defaults to 10
max_scan_distance = 40 # defaults to 60
scan_locations = st_transform(scan_locations, get_ctg_crs(ctg)))
scan_locations = st_transform(scan_locations, get_ctg_crs(ctg))
# Load plot boundaries/buffer and create filter
hdr = lidR::readLASheader(ctg$filename[1])
proj = sf::st_crs(hdr@VLR$`WKT OGC CS`$`WKT OGC COORDINATE SYSTEM`)
suppressMessages(sf::st_crs(bnd) <- proj)
bnd_buff = sf::st_buffer(bnd, dist=buffer)
ex = sf::st_bbox(bnd_buff)
filt = paste('-keep_xy', ex[1], ex[2], ex[3], ex[4]) #min_x min_y max_x max_y
tmp = ex/tile_size
ex = c(floor(tmp[1]), floor(tmp[2]), ceiling(tmp[3]), ceiling(tmp[4]))*tile_size
lidR::opt_filter(ctg) = filt
#create fishnet from extent
ncol = (ex[3] - ex[1])/tile_size
nrow = (ex[4] - ex[2]) / tile_size
grid = terra::rast(extent=ext(ex[c(1,3,2,4)]), ncols=ncol, nrows=nrow)
grid = terra::as.polygons(grid)
grid = sf::st_as_sf(grid)
sf::st_crs(grid) = proj
#ex = sf::st_as_sf(terra::as.polygons(round(terra::ext(bnd_buff), 1)))
grid = grid[sf::st_intersects(grid, bnd_buff, sparse=FALSE),]
#Check to see what all is already complete
todo_list = c()
for(t in 1:nrow(grid)){
tile = grid[t,]
ex = round(sf::st_bbox(tile),1)
out_las = paste0(out_dir, '/', ex[1], '_', ex[2], '.laz')
out_las = gsub('\\/\\/', '\\/', out_las)
if(!file.exists(out_las))  todo_list = c(todo_list, t)
}
if(length(todo_list)<1) {
cat('all scans already tiled')
return(NULL)
}
#Get all scan centroids once
if(is.null(scan_locations)) {
cat('finding all scan footprints within', max_scan_distance, 'meters\n')
scan_locations = list()
i=1
for(fn in ctg$filename) {
cat('.....',i, 'of', length(ctg$filename), '\n')
scan_centroid = suppressMessages(find_las_centroid(fn))
scan_location = sf::st_buffer(scan_centroid, dist=max_scan_distance)
scan_location$fn=fn
scan_locations[[length(scan_locations)+1]] = scan_location
i=i+1
}; scan_locations = do.call(rbind , scan_locations)
}
scan_locations = sf::st_buffer(scan_locations, dist=max_scan_distance)
plot(scan_locations$geometry, col=rgb(0,0,1,0.05))
plot(grid$geometry, add= TRUE, border='red')
plot(bnd$geometry, lwd = 2, border = "black", add = TRUE)
Sys.sleep(0.5)
# run through grid tiles, load proximal TLS scans from directory and clip to bnd. rbind, and write to file.
cl = parallel::makeCluster(n_cores)
doSNOW::registerDoSNOW(cl)
pb = utils::txtProgressBar(max = length(todo_list), style = 3)
progress = function(n) utils::setTxtProgressBar(pb, n)
opts = list(progress = progress)
# Load and display tile
cat('\nloading tile', t, 'of', nrow(grid), '\n')
t = todo_list[1]
t
todo_list
# Load and display tile
cat('\nloading tile', t, 'of', nrow(grid), '\n')
tile = grid[t,]
ex = sf::st_bbox(tile)
out_las = paste0(out_dir, '/', ex[1], '_', ex[2], '.laz')
out_las = gsub('\\/\\/', '\\/', out_las)
if(file.exists(out_las)) return(NULL)
scans_to_load = which(sf::st_intersects(tile, scan_locations, sparse = FALSE))
scans_to_load
scans_to_load = dplyr::slice(scan_locations, scans_to_load)
if(nrow(scans_to_load)<1) return(NULL)
#loop through relevant scans, clip and
combined_las = list()
filt = paste('-keep_xy', ex[1], ex[2], ex[3], ex[4]) #min_x min_y max_x max_y
filt
i=1
cat('.....appending scan', i, 'of', nrow(scans_to_load), '\n')
roi = sf::st_intersection(tile, scans_to_load[i,])
for(i in 1:nrow(scans_to_load)) {
cat('.....appending scan', i, 'of', nrow(scans_to_load), '\n')
roi = sf::st_intersection(tile, scans_to_load[i,])
combined_las[[i]] = lidR::clip_roi(lidR::readLAS(scans_to_load[i,]$fn, filter=filt), roi)
}
combined_las[[1]]
colnames(combined_las[[1]]@data)
#To avoid rbind errors, Find common columns among scans and keep only those
combined_las = combined_las[!sapply(combined_las, is.null)]
common_cols = lapply(combined_las, function(x) colnames(x@data))
common_cols = Reduce(intersect, common_cols)
common_cols
common_cols = lapply(combined_las, function(x) colnames(x@data))
common_cols = Reduce(intersect, common_cols)
cols_to_keep = c('X', 'Y', 'Z', 'gpstime', 'Intensity', 'ReturnNumber', "NumberOfReturns", 'Classification', 'Reflectance', 'Deviation')
if('Distance' %in% common_cols) cols_to_keep = c(cols_to_keep, 'Distance')
cols_to_keep
combined_las = lapply(combined_las, function(x) {
x@data = x@data[, cols_to_keep]
return(x)})
combined_las
x = combined_las[[1]]
x@data
x@data[, cols_to_keep]
x@data[, eval(cols_to_keep)]
cols_to_keep
x@data[cols_to_keep]
x@data[,cols_to_keep]
x@data[,eval(cols_to_keep)]
x@data[eval(cols_to_keep)]
dplyr::select(x@data, cols_to_keep))
dplyr::select(x@data, .cols_to_keep)
dplyr::select(x@data, cols_to_keep)
dplyr::select(x@data, all_of(cols_to_keep))
combined_las = lapply(combined_las, function(x) {
x@data = dplyr::select(x@data, all_of(cols_to_keep))
return(x)})
colnames(combined_las@data)
#make sure las portion with highest NumberofReturns is listed first so bit count is set correctly
whichMaxReturns = which.max(sapply(combined_las, function(x) max((x@data$NumberOfReturns))))
n = c(whichMaxReturns, (1:length(combined_las))[-whichMaxReturns])
combined_las = do.call(rbind,combined_las[n])
combined_las@header@VLR = list()
st_crs(combined_las) = proj
las_update(combined_las)
las = las_update(combined_las)
las$Distance
hist(las$Distance)
combined_las = las_update(combined_las)
#write tile to disk
cat('.....scans stitched. writing tile to disk')
lidR::writeLAS(lidR::las_update(combined_las), out_las, index=TRUE)
out_las
combined_las
combined_las@data
dist = combined_las$Distance
lidR::add_lasattribute(combined_las, dist, 'Distance')
x = lidR::add_lasattribute(combined_las, dist, 'Distance', 'Distance from scanner')
x
lidR::writeLAS(x, out_las, index=TRUE)
x = readLAS(out_las)
colnames(x@data)
plot(x, color='Distance', backend='lidRviewer')
library(landecoutils)
library(lidR)
laz_dir = 'X:/testing_density/'
output_dir = laz_dir
dir.create(paste0(output_dir, '/tiled'))
default_proj = 'epsg:32616'
ctg = readLAScatalog(laz_dir);
plot(ctg)
# Code to loop through and replace all .laz with distance files
las_fns = list.files(laz_dir, pattern = '.las|.laz', full.names=TRUE)
for(las_fn in las_fns) {
# Add distance to laz file
las = las_add_scanner_distance(las_fn)
if(is.null(las)) {
warning('skipping\n')
next
}
ext = tools::file_ext(las_fn)
tmp_filename = gsub(paste0('.', ext, '$'), paste0('_tmp.', ext), las_fn)
message('... writing file')
lidR::writeLAS(las, tmp_filename)
if(file.exists(tmp_filename)) {
file.copy(tmp_filename,las_fn, overwrite = TRUE)
if(file.exists(las_fn)) unlink(tmp_filename)
}
# Load or generate scan locations
scan_locations = paste0(output_dir, '/scan_locs.shp')
if(!file.exists(scan_locations)) {
proj = get_ctg_crs(ctg)
tmp = landecoutils::find_ctg_centroids(ctg, 4)
sf::st_crs(tmp) = proj
tmp = sf::st_transform(tmp, default_proj)
# be sure to write output locations##
write_sf(tmp, scan_locations) # be sure to give output loc.
}; scan_locations = read_sf(scan_locations)
# Load or generate site boundary
bnd = paste0(output_dir, '/boundary.shp')
if(!file.exists(bnd)) {
tmp = scan_locations
tmp = st_convex_hull(st_union(tmp))
sf::st_crs(tmp) = st_crs(scan_locations)
write_sf(tmp, bnd)
}; bnd = read_sf(bnd)
#Stitch and merge scans into tiles
ctg = readLAScatalog(laz_dir); plot(ctg)
opt_chunk_alignment(ctg) = c(0,0)
stitch_TLS_dir_to_LAS_tiles(ctg = ctg,
out_dir = paste0(output_dir,'/tiled/'),
bnd = st_transform(bnd, get_ctg_crs(ctg)),
tile_size = 30,
n_cores = 1,
buffer = 5, #defaults to 10
max_scan_distance = 40, # defaults to 60
scan_locations = st_transform(scan_locations, get_ctg_crs(ctg)))
library(landecoutils)
